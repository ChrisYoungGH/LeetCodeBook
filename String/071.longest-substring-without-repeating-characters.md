## 最长的非重复字符的子串
### 解法
用map维护当前字符的最新位置, 每次判断是否要更新起始点:
- 若map不存在该字符, 不更新
- 若map存在该字符, 比较当前起始点与上一个该字符位置下一个位置的大小
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int maxLen = 0;
        map<char, int> pos;
        int start = 0;
        
        for (int i = 0; i < s.length(); i++) {
            if (pos.find(s[i]) != pos.end()) {
                start = max(start, pos[s[i]] + 1);
            }
            pos[s[i]] = i;
            maxLen = max(maxLen, i - start + 1);
        }
        
        return maxLen;
    }
};
```