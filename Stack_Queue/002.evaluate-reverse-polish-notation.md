## 逆波兰表达式四则运算

### 解法
每次遇到数则压入栈, 遇到符号则从栈中弹出两个数计算后压入栈, 最后返回栈顶元素 (检查各种边界).

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int n = tokens.size();
        if (!n) {
            return 0;
        }
        
        set<string> operations = {"+", "-", "*", "/"};
        
        stack<int> buffer;
        
        for (int i = 0; i < n; i++) {
            string curr = tokens[i];
            if (operations.find(curr) != operations.end()) {
                if (buffer.size() < 2) {
                    return 0;
                }
                
                int num2 = buffer.top();
                buffer.pop();
                int num1 = buffer.top();
                buffer.pop();
                
                int num;
                if (curr == "+") {
                    num = num1 + num2;
                }
                else if (curr == "-") {
                    num = num1 - num2;
                }
                else if (curr == "*") {
                    num = num1 * num2;
                }
                else if (curr == "/") {
                    num = num1 / num2;
                }
                
                buffer.push(num);
            }
            
            else {
                int num;
                try {
                    num = stoi(tokens[i]);
                }
                catch (exception &e) {
                    return 0;
                }
                buffer.push(num);
            }
        }
        
        return tokens.size() == 1 || 
            (operations.find(tokens.back()) != operations.end() && buffer.size() == 1) ? buffer.top() : 0;
    }
};
```