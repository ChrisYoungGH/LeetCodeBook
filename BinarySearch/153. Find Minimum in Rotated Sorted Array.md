#### 二分查找(O(logn))

由于是升序数组的截断, 故如果截断位置是N \ [0,n-1] (相当于未截断), 则last > first; 否则last < first;

每次缩小区间要保留mid作比较(与二分找已知值不同)

先判断是否rotate, 再判断rotate了的情况.

```c++
int findMin(vector<int> &nums) {
	int l = 0, r = int(nums.size()) - 1;
	
	if (nums[l] < nums[r]) {
		return nums[0];
	}
	
	while (l < r - 1) {
		int m = (l + r) / 2;
		if (nums[m] < nums[l]) {
			r = m;
		}
		else {
			l = m;
		}
	}

	return nums[r];
}
```

#### 顺序查找(O(n))

返回比前一个值小的数.

```c++
int findMin(vector<int> &nums) {
	for (int i = 0; i < int(nums.size()) - 1; i++) {
		if (nums[i] > nums[i+1]) {
			return nums[i+1];
		}
	}
	return nums[0];
}
```