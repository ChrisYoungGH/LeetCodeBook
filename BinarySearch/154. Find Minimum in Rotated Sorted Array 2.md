类似153, 但需要处理重复值的情况.

首先依然先判断是否已经有序.

分a[m] <;>;= a[l]三种情况, 前两种同153.

a[m] == a[l] 时, 比较a[m]与a[r]:
- a[m] > a[r], 则处理右端
- a[m] == a[r] (因为若非有序则a[l]>=a[r], 而a[m]==a[l]), 则有可能在左边也有可能在右边,如: 
`[1,1,0,1]`, `[1,0,1,1,1]`. 
此时l跳到下一位置, 同时判断[l,r]是否已经有序.

最坏情况, 数组每个元素都相同, 退化到线性查找.


```c++
int findMin(vector<int> &nums) {
	int l = 0, r = int(nums.size()) - 1;
	
	// [l,r] is sorted
	if (nums[l] < nums[r]) {
		return nums[l];
	}

	while (l < r - 1) {
		int m = (l + r) / 2;
		if (nums[m] > nums[l]) {
			l = m;
		}
		else if (nums[m] < nums[l]) {
			r = m;
		}
		else {	// nums[m] == nums[l]
			if (nums[m] > nums[r]) {
				l = m;
			}
			else {	// nums[m] == nums[r]
				l++;

				// [l,r] is sorted
				if (nums[l] < nums[r]) {
					return nums[l];
				}
			}
		}
	}

	return min(nums[l], nums[r]);
}
```