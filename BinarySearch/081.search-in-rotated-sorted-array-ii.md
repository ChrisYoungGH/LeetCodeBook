# 搜索旋转排序数组 II（Search in Rotated Sorted Array II）*Medium*
### [原题链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii)（[Origin](https://leetcode.com/problems/search-in-rotated-sorted-array-ii)）
## 描述
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组[0,0,1,2,2,5,6]可能变为[2,5,6,0,0,1,2])。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回true，否则返回false。

**示例1:**
```
输入: nums = [2,5,6,0,0,1,2], target = 0

输出: true
```


**示例2:**
```
输入: nums = [2,5,6,0,0,1,2], target = 3

输出: false
```

进阶:


    这是 搜索旋转排序数组的延伸题目，本题中的nums 可能包含重复元素。
    这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？


## Description
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).

You are given a target value to search. If found in the array return true, otherwise return false.

**Example 1:**
```
Input: nums = [2,5,6,0,0,1,2], target = 0

Output: true
```


**Example 2:**
```
Input: nums = [2,5,6,0,0,1,2], target = 3

Output: false
```

Follow up:


    This is a follow up problem toSearch in Rotated Sorted Array, where nums may contain duplicates.
    Would this affect the run-time complexity? How and why?



## 旋转数组找数, 其中有重复
### 解法
- 左中右相等则左右往中间收缩.
- 如果左边非降, 根据端点判断是否落在左边, 否则往右边寻找;
- 否则一定是右边非降,  根据两个端点判断是否落在右边, 否则往左边查找.

要点：先判相等，再跳过重复，最后看哪边升序。
```c++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int n = nums.size();
        if (!n) {
            return false;
        }
        
        int low = 0, high = n - 1;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (target == nums[mid]) {
                return true;
            }
            
            if (nums[mid] == nums[low] && nums[mid] == nums[high]) {
                low++;
                high--;
            }
            else if (nums[low] <= nums[mid]) {
                if (target < nums[mid] && target >= nums[low]) high = mid - 1;
                else low = mid + 1;
            }
            else {
                if (target > nums[mid] && target <= nums[high]) low = mid + 1;
                else high = mid - 1;
            }
        }
        
        return nums[low] == target;
    }
};
```