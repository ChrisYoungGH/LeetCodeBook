从除数开始依次往上翻倍， 直到超过被除数后返回到与剩余值最接近的值再不断递减。
```c++
int divide0(int dividend, int divisor) {
	if (divisor == 0) {
		return INT_MAX;
	}

	unsigned int u_divisor = divisor >= 0 ? divisor : (unsigned int)(-divisor);
	unsigned int u_dividend = dividend >= 0 ? dividend : (unsigned int)(-dividend);

	if (u_dividend < u_divisor) {
		return 0;
	}

	int flag = (dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0) ? 1 : -1;

	unsigned int u_res = 1;
	unsigned int u_base[32] = {u_divisor, 0};
	unsigned int times[32] = {u_res, 0};

	int m = 0;
	while ((u_divisor << 1) <= u_dividend) {
		if ((u_divisor << 1) < u_divisor) {
			break;
		}

		u_res <<= 1;
		m++;
		times[m] = u_res;
		u_divisor <<= 1;
		u_base[m] = u_divisor;

		// printf("%u %u\n", u_divisor, u_res);
	}

	bool more = true;
	while (u_divisor < u_dividend) {
		while (u_divisor + u_base[m] > u_dividend) {
			m--;
			if (m < 0) {
				more = false;
				break;
			}
		}

		if (more == false) {
			break;
		}

		u_res += times[m];
		u_divisor += u_base[m];

	}

	int res = flag > 0 ? u_res : -u_res;

	if ((flag > 0 && res < 0) || (flag < 0 && res > 0)) {
		return INT_MAX;
	}

	return res;
}
```