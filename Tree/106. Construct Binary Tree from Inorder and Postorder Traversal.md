后序的根一定在最右，中序的左右子树分别在根两侧，各种序的左(右)子树长度相等。

根据后序得到的根val在中序中找index。

1. 用二分：STL的find或lower_bound(+1)或upper_bound(-1)

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return build(inorder, postorder, 0, 0, int(inorder.size()));
    }
    
    TreeNode *build(vector<int> &inorder, vector<int> &postorder, 
            int i_begin, int p_begin, int length) {
        if (length == 0) {
            return NULL;
        }
        if (length == 1) {
            return new TreeNode(inorder[i_begin]);
        }

        int root_val = postorder[p_begin + length - 1];
        int i_root_index = index(inorder, root_val, i_begin, length);
        int left_length = i_root_index - i_begin;
        int right_length = length - (i_root_index - i_begin) - 1;
        int i_right_begin = i_root_index + 1;
        int p_right_begin = left_length + p_begin;

        TreeNode *root = new TreeNode(root_val);
        root->left = build(inorder, postorder, i_begin, p_begin, left_length);
        root->right = build(inorder, postorder, i_right_begin, p_right_begin, right_length);

        return root;
    }
    
    int index(vector<int> &arr, int val, int offset, int length) {
        vector<int>::iterator lower = find(arr.begin() + offset, arr.begin() + offset + length, val);
        int index = lower - arr.begin();
        return index;
    }
};
```

2. 用map先存先序值的下标，再每次根据val找index。空间换时间。

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int> &inorder, vector<int> &postorder) {
        if (postorder.empty()) {
            return NULL;
        }

        unordered_map<int, int> i_index;
        for (int i = 0; i < inorder.size(); i++) {
            i_index[inorder[i]] = i;
        }

        return build(inorder, postorder, 0, int(inorder.size())-1, 0, int(postorder.size())-1, i_index);
    }
    
    
    TreeNode *build(vector<int>& inorder, vector<int> &postorder,
            int i_begin, int i_end, int p_begin, int p_end,
            unordered_map<int, int> &i_index) {
        if (i_begin > i_end || p_begin > p_end) {
            return NULL;
        }

        int root_val = postorder[p_end];
        int i_root_index = i_index[root_val];
        int length = i_root_index - i_begin;

        TreeNode *root = new TreeNode(root_val);
        root->left = build(inorder, postorder, i_begin, i_root_index - 1, p_begin, p_begin + length - 1, i_index);
        root->right = build(inorder, postorder, i_root_index + 1, i_end, p_begin + length, p_end - 1, i_index);

        return root;
    }
};
```