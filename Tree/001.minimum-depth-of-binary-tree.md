## 二叉树的最短路径长度

### 解法1
四种情况:
- 空返回0
- 左右都空返回1
- 左空或右空返回右最小或左最小
- 左右非空返回左右最小的较小者
```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        if (!root->left && !root->right) {
            return 1;
        }
        int ld = 0, rd = 0;
        if (!root->left) {
            return minDepth(root->right) + 1;
        }
        if (!root->right) {
            return minDepth(root->left) + 1;
        }
        return min(minDepth(root->left), minDepth(root->right)) + 1;
    }
};
```


### 解法2
DFS过程维护一全局最小深度变量, 每当到达叶子节点时比较深度并更新.
```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        
        int minDepth = -1;
        
        dfs(root, 1, minDepth);
        
        return minDepth;
    }
    
    void dfs(TreeNode *root, int depth, int &minDepth) {
        if (!root->left && !root->right) {
            if (minDepth == -1) {
                minDepth = depth;
            }
            else {
                minDepth = min(minDepth, depth);
            }
            return;
        }
        
        if (root->left) {
            dfs(root->left, depth+1, minDepth);
        }
        if (root->right) {
            dfs(root->right, depth+1, minDepth);
        }
    }
    
    
};
```