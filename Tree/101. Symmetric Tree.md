- 方法1: 同102, 层序遍历. 每次遍历完一层之后判断该层是否对称.
- 方法2: 使用两个队列分别层序遍历根节点的左右子树, 左子树的队列先放节点左孩子再放右孩子, 右子树队列先放节点右孩子再放左孩子, 每次分别从左右队列出队一个节点并比较.
- **注意**: 不管上面哪种方法, 对于非空节点, 需要将其左右孩子都入队, 故入队的节点有可能是null. 原因是为了保持镜像性. 例子: 对于下面这棵树, 在最后一层时, 比较下面两种情况:
```
    1                   1
   / \                 / \
  2   2               2   2
   \   \             /     \
   3    3           3       3
    (1)                 (2)
```

- 对于图(1):
    - 如果不入队null, 则level为[3,3], 变为对称了.
    - 左右孩子不管是否null都入队, 则level为[null,3,null,3], 不是对称.
- 对于图(2):
    - 左右孩子都入队, level为[3,null,null,3], 是对称的.

方法1:
```c++
bool isSymmetric(TreeNode* root) {
    if (!root) {
        return true;
    }

    vector<int> level;
    queue<TreeNode*> q;
    q.push(root);
    int currLen = 1, nextLen = 0;

    while (!q.empty()) {
        TreeNode *curr = q.front();
        level.push_back(curr ? curr->val : INT_MIN);
        q.pop();
        currLen--;

        if (curr) {
            q.push(curr->left);
            q.push(curr->right);
            nextLen += 2;
        }

        if (currLen == 0) {
            if (!isSymmetric(level)) {
                return false;
            }

            level.resize(0);

            currLen = nextLen;
            nextLen = 0;
        }
    }

    return true;
}

bool isSymmetric(vector<int> &vec) {
    for (int i = 0; i < vec.size() / 2; i++) {
        if (vec[i] != vec[vec.size() - i - 1]) {
            return false;
        }
    }
    return true;
}
```

方法2:
```c++
bool isSymmetric(TreeNode *root) {
    if (!root) {
        return true;
    }

    queue<TreeNode*> leftq, rightq;
    leftq.push(root->left);
    rightq.push(root->right);

    while (!leftq.empty() && !rightq.empty()) {
        TreeNode *left = leftq.front();
        leftq.pop();
        TreeNode *right = rightq.front();
        rightq.pop();

        if (!left && !right) {
            return continue;
        }
        if (!left || !right) {
            return false;
        }
        if (left->val != right->val) {
            return false;
        }

        leftq.push(left->left);
        leftq.push(left->right);
        rightq.push(right->right);
        rightq.push(right->left);
    }

    return (leftq.empty() && rightq.empty());
}
```