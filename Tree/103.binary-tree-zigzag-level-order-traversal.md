# 二叉树的锯齿形层次遍历（Binary Tree Zigzag Level Order Traversal）*Medium*
### [原题链接](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal)（[Origin](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal)）
## 描述
给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树[3,9,20,null,null,15,7],
```

    3
   / \
  9  20
    /  \
   15   7
```


返回锯齿形层次遍历如下：
```

[
  [3],
  [20,9],
  [15,7]
]
```

## Description
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).


For example:
Given binary tree [3,9,20,null,null,15,7],
```

    3
   / \
  9  20
    /  \
   15   7
```



return its zigzag level order traversal as:
```

[
  [3],
  [20,9],
  [15,7]
]
```


解法: 两个栈存奇偶行

```c++
class Solution {
public:
	vector<vector<int> > zigzagLevelOrder(TreeNode *root) {
		vector<vector<int> > res;
		if (!root) return res;

		stack<TreeNode*> levels[2];
		int curr = 0, next = 1;
		levels[0].push(root);

		vector<int> line;

		while (!levels[0].empty() || !levels[1].empty()) {
			TreeNode *node = levels[curr].top();
			levels[curr].pop();
			line.emplace_back(node->val);

			if (!curr) {
				if (node->left) levels[next].push(node->left);
				if (node->right) levels[next].push(node->right);
			}
			else {
				if (node->right) levels[next].push(node->right);
				if (node->left) levels[next].push(node->left);
			}

			if (levels[curr].empty()) {
				res.emplace_back(line);
				line.clear();
				curr = next;
				next = 1 - next;
			}
		}

		return res;
	}
};
```