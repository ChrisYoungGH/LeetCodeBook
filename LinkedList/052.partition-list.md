## 拆分链表, 比给定数小的在前, 大的在后, 保持顺序
### 解法
逻辑上维护一个新链表表示大的数, 遇到大的数往新链表添加.
- 注意维护原链表的前节点(即判断curr->next)
- 注意新链表末尾要置空.
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *dummy = new ListNode(-1);
        dummy->next = head;
        ListNode *curr = dummy;
        
        ListNode *large = new ListNode(-1);
        ListNode *currL = large;
        
        while (curr->next) {
            if (curr->next->val >= x) {
                currL->next = curr->next;
                currL = currL->next;
                
                curr->next = curr->next->next;
            }
            else {
                curr = curr->next;
            }
        }
        
        currL->next = NULL;
        curr->next = large->next;
        head = dummy->next;
        
        delete dummy;
        delete large;
        
        return head;
    }
};
```