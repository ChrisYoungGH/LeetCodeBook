## binary数组中0和1数量相等的最长连续子序列.

### 解法
先将0变成-1, 则转变为preSum问题, 找到j使得preSum(j)的值在先前出现, 不妨设i, 即preSum(j) = preSum(i), 则sum(i+1 ~ j) = 0, 此时0和1的个数相等. hash表存下标, 每次找到则更新最长, 找不到再存入hash表. O(n).

```c++
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) {
                nums[i] = -1;
            }
        }
        
        unordered_map<int, int> hash;
        hash[0] = -1;
        
        int sum = 0, maxLen = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            if (hash.find(sum) != hash.end()) {
                maxLen = max(maxLen, i - hash[sum]);
            }
            else {
                hash[sum] = i;
            }
        }
        
        return maxLen;
    }
};
```