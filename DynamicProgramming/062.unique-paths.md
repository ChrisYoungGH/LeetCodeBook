# 不同路径（Unique Paths）
## 概况
**标签**：*`Dynamic-programming`*  *`Array`*<br>
**难度**：★★<br>
**评分**：★★★★★<br>
**原题**：[中文](https://leetcode-cn.com/problems/unique-paths) / [英文](https://leetcode.com/problems/unique-paths)
## 描述

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为&ldquo;Start&rdquo; ）。



机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为&ldquo;Finish&rdquo;）。



问总共有多少条不同的路径？







例如，上图是一个7 x 3 的网格。有多少可能的路径？



说明：m和 n 的值均不超过 100。



**示例1:**

```

输入: m = 3, n = 2



输出: 3



解释:

从左上角开始，总共有 3 条路径可以到达右下角。

1. 向右 -> 向右 -> 向下

2. 向右 -> 向下 -> 向右

3. 向下 -> 向右 -> 向右

```





**示例2:**

```

输入: m = 7, n = 3



输出: 28

```



## Description

A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).



The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).



How many possible unique paths are there?





Above is a 7 x 3 grid. How many possible unique paths are there?



**Note:**

 m and n will be at most 100.



**Example 1:**

```

Input: m = 3, n = 2



Output: 3



Explanation:

From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:

1. Right -> Right -> Down

2. Right -> Down -> Right

3. Down -> Right -> Right

```





**Example 2:**

```

Input: m = 7, n = 3



Output: 28

```





## 从左上角到右下角可能的路径数

### 解法

DP更新公式:

    

    f(i,j) = f(i-1,j) + f(i,j-1)



用一维数组表示是 

    

    f(j) = f(j-1) + f(j)

    

```c++

class Solution {

public:

    int uniquePaths(int m, int n) {

        vector<int> dp(n, 1);

        

        for (int i = 1; i < m; i++) {

            for (int j = 1; j < n; j++) {

                dp[j] += dp[j-1];

            }

        }

        

        return dp.back();

    }

};

```





### 解法2

优化: 斜着看其实为杨辉三角, 每个数即为一个二项式系数, 点(m,n)的结果为C_(m+n-2)^(n-1).

```c++

class Solution {

public:

    int uniquePaths(int m, int n) {

        long res = 1;

        int t = min(m, n);

        for (int i = 1; i <= t - 1; i++) {

            res = res * (m + n - i - 1) / i;

        }

        return res;

    }

};

```