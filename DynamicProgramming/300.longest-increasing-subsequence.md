# 最长上升子序列（Longest Increasing Subsequence）*Medium*
### [原题链接](https://leetcode-cn.com/problems/longest-increasing-subsequence)（[Origin](https://leetcode.com/problems/longest-increasing-subsequence)）
## 描述
给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**
```
输入: [10,9,2,5,3,7,101,18]

输出: 4 

解释: 最长的上升子序列是[2,3,7,101]，它的长度是 4。
```

说明:


	可能会有多种最长上升子序列的组合，你只需要
输出对应的长度即可。
	你算法的时间复杂度应该为O(n2) 。


进阶: 你能将算法的时间复杂度降低到O(n log n) 吗?

## Description
Given an unsorted array of integers, find the length of longest increasing subsequence.

**Example:**
```
Input: [10,9,2,5,3,7,101,18]

Output: 4 

Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
```
**Note:**
 


	There may be more than one LIS combination, it is only necessary for you to return the length.
	Your algorithm should run in O(n2) complexity.


Follow up: Could you improve it to O(n log n) time complexity?


## 数组最长连续递增子序列长度
### 解法1 (O(n^2))
DP更新公式:
 
    f(i) = max{f(j)}, 0<=j<i, if a[i]>a[j]
    
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if (!n) {
            return 0;
        }
        
        int maxLen = 1;
        int dp[n] = {0};
        dp[0] = 1;
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j]);
                }
            }
            dp[i]++;
            maxLen = max(maxLen, dp[i]);
        }
        
        return maxLen;
    }
};
```

### 解法2：O(nlogn)
s(i)表示数组a[0...i]的最长递增子序列, 则更新公式:

    s(i) = s(i-1),     if a[i] <= s(i-1)[-1]
         = s(i-1) + 1, if a[i] >  s(i-1)[-1]

即维护当前的最长递增子序列, 如果当前数能够插入中间则更新(放在第一个大于该数的数的位置), 否则追加. 每一步查找是二分.
         
每次将当前数放到尾部数组第一个比当前数大的位置，因为往后肯定是比当前数大且下标小的数，不符合要求，往前都是小的数，且是当前最长。每步都是二分查找，一共O(nlogn)
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> tails;
        for (int num : nums) {
            if (!tails.size() || num > tails.back()) {
                tails.push_back(num);
            }
            else {
                // binary search: first place that >= num
                int low = 0, high = int(tails.size())-1;
                while (low < high) {
                    int mid = (low + high) / 2;
                    if (tails[mid] < num) low = mid + 1;
                    else high = mid;
                }
                tails[low] = num;
            }
        }
        return tails.size();
    }
};
```